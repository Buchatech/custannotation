<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom Annotator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <style>
        :root {
            --bg-color: #ffffff;
            --text-color: #333333;
            --top-bar-bg: #673AB7;
            --top-bar-text: #ffffff;
            --card-bg: #ffffff;
            --card-shadow: rgba(0, 0, 0, 0.1);
            --btn-primary: #9C27B0;
            --btn-primary-hover: #7B1FA2;
            --btn-danger: #757575;
            --btn-danger-hover: #616161;
            --btn-secondary: #673AB7;
            --btn-secondary-hover: #512DA8;
            --btn-red: #e53935;
            --btn-red-hover: #c62828;
            --btn-green: #43a047;
            --btn-green-hover: #2e7d32;
            --input-border: #ddd;
            --anno-item-bg: #f9f9f9;
            --anno-item-border: #673AB7;
            --success-bg: #E1BEE7;
            --success-text: #4A148C;
            --error-bg: #f2dede;
            --error-text: #a94442;
            --canvas-border: #ddd;
            --circle-color: #ffeb3b;  /* Yellow */
            --circle-fill: rgba(255, 235, 59, 0.2);
            --triangle-color: #ff9800;  /* Orange */
            --triangle-fill: rgba(255, 152, 0, 0.2);
            --line-color: #f44336;  /* Red */
            --rotate-hint-color: rgba(156, 39, 176, 0.5);  /* Purple with transparency */
        }

        .dark-theme {
            --bg-color: #121212;
            --text-color: #e0e0e0;
            --top-bar-bg: #4A148C;
            --top-bar-text: #ffffff;
            --card-bg: #1e1e1e;
            --card-shadow: rgba(0, 0, 0, 0.3);
            --btn-primary: #9C27B0;
            --btn-primary-hover: #7B1FA2;
            --btn-danger: #616161;
            --btn-danger-hover: #424242;
            --btn-secondary: #673AB7;
            --btn-secondary-hover: #512DA8;
            --btn-red: #e53935;
            --btn-red-hover: #c62828;
            --btn-green: #43a047;
            --btn-green-hover: #2e7d32;
            --input-border: #444;
            --anno-item-bg: #2a2a2a;
            --anno-item-border: #9C27B0;
            --success-bg: #311B92;
            --success-text: #E1BEE7;
            --error-bg: #731c1c;
            --error-text: #f5c6c6;
            --canvas-border: #444;
            --circle-color: #ffeb3b;  /* Yellow */
            --circle-fill: rgba(255, 235, 59, 0.2);
            --triangle-color: #ff9800;  /* Orange */
            --triangle-fill: rgba(255, 152, 0, 0.2);
            --line-color: #f44336;  /* Red */
            --rotate-hint-color: rgba(171, 71, 188, 0.5);  /* Lighter purple with transparency */
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
        }
        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            background-color: var(--top-bar-bg);
            padding: 10px 20px;
            border-radius: 8px;
            color: var(--top-bar-text);
            box-shadow: 0 2px 5px var(--card-shadow);
        }
        h1 {
            color: var(--top-bar-text);
            margin: 0;
        }
        .content {
            display: flex;
            gap: 20px;
        }
        .canvas-container {
            flex: 1;
            background-color: var(--card-bg);
            border-radius: 8px;
            box-shadow: 0 2px 10px var(--card-shadow);
            padding: 10px;
        }
        .sidebar {
            width: 300px;
            background-color: var(--card-bg);
            border-radius: 8px;
            box-shadow: 0 2px 10px var(--card-shadow);
            padding: 20px;
        }
        .canvas-wrapper {
            position: relative;
            margin-bottom: 20px;
        }
        canvas {
            border: 1px solid var(--canvas-border);
            display: block;
        }
        .btn {
            background-color: var(--btn-primary);
            color: white;
            border: none;
            padding: 8px 16px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 14px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.3s;
        }
        .btn:hover {
            background-color: var(--btn-primary-hover);
        }
        .btn-danger {
            background-color: var(--btn-danger);
        }
        .btn-danger:hover {
            background-color: var(--btn-danger-hover);
        }
        .btn-secondary {
            background-color: var(--btn-secondary);
        }
        .btn-secondary:hover {
            background-color: var(--btn-secondary-hover);
        }
        .btn-red {
            background-color: var(--btn-red);
        }
        .btn-red:hover {
            background-color: var(--btn-red-hover);
        }
        .btn-green {
            background-color: var(--btn-green);
        }
        .btn-green:hover {
            background-color: var(--btn-green-hover);
        }
        .btn-group {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        #class-icon-toolbar {
            display: flex;
            gap: 6px;
        }
        .class-icon-button {
            width: 36px;
            height: 36px;
            padding: 0;
            box-sizing: border-box;
            border: 2px solid transparent;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            margin: 0 4px;
        }
        .class-icon-button svg {
            width: 24px;
            height: 24px;
        }
        .class-icon-button:hover {
            border-color: var(--btn-primary-hover);
            transform: translateY(-1px);
            background-color: var(--bg-color);
        }
        .class-icon-button.active-icon {
            border-color: var(--btn-primary);
            background-color: var(--btn-secondary-hover);
            box-shadow: 0 0 8px var(--btn-primary);
            transform: scale(1.05);
        }
        .class-icon-button.active-icon svg {
            stroke: white;
            fill: white;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: var(--btn-secondary);
        }
        input, select {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--input-border);
            border-radius: 4px;
            box-sizing: border-box;
            background-color: var(--card-bg);
            color: var(--text-color);
        }
        .annotations-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--input-border);
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
        }
        .annotation-item {
            background-color: var(--anno-item-bg);
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 4px;
            border-left: 4px solid var(--anno-item-border);
        }
        .status-message {
            margin-top: 20px;
            padding: 10px;
            border-radius: 4px;
        }
        .success {
            background-color: var(--success-bg);
            color: var(--success-text);
        }
        .error {
            background-color: var(--error-bg);
            color: var(--error-text);
        }
        .theme-toggle {
            display: flex;
            align-items: center;
        }
        .theme-toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 30px;
        }
        .theme-toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .theme-toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        .theme-toggle-slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .theme-toggle-slider {
            background-color: #2196F3;
        }
        input:checked + .theme-toggle-slider:before {
            transform: translateX(30px);
        }
        .theme-icon {
            margin: 0 10px;
            font-size: 18px;
        }

        /* New styles for floating toolbar */
        .floating-toolbar {
            position: absolute;
            top: 80%;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--card-bg);
            padding: 8px 12px;
            border-radius: 8px;
            box-shadow: 0 4px 12px var(--card-shadow);
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toolbar-separator {
            width: 1px;
            height: 24px;
            background-color: var(--input-border);
            margin: 0 4px;
        }
        /* Ensure action buttons in toolbar also use SVG color correctly */
        /* REMOVED: .floating-toolbar .class-icon-button svg { stroke: var(--text-color); } */
        /* REMOVED: .floating-toolbar .class-icon-button:hover svg { stroke: var(--btn-primary-hover); } */
         /* Ensure active class icons in toolbar have white SVGs */
         /* This rule might be redundant if the general .class-icon-button.active-icon svg is sufficient */

        .sidebar-warning {
            background-color: var(--error-bg); 
            color: var(--error-text);
            padding: 10px;
            margin-top: 15px;
            margin-bottom: 15px;
            border-radius: 4px;
            font-size: 0.9em;
            border: 1px solid var(--error-text); 
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="top-bar">
            <h1>Custom Annotator</h1>
            <div class="theme-toggle">
                <span class="theme-icon">☀️</span>
                <label class="theme-toggle-switch">
                    <input type="checkbox" id="theme-toggle">
                    <span class="theme-toggle-slider"></span>
                </label>
                <span class="theme-icon">🌙</span>
            </div>
        </div>
        
        <div class="content">
            <div class="canvas-container">
                <div class="canvas-wrapper">
                    <!-- Floating Toolbar -->
                    <div class="floating-toolbar">
                         <div id="dynamic-class-icons-toolbar" style="display: flex; align-items: center; gap: 6px;">
                            <button id="select-mode-btn" class="class-icon-button active-icon" title="Select Tool">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3l7.07 16.97l2.51-7.39l7.39-2.51L3 3z"></path><path d="M13 13l6 6"></path></svg>
                            </button>
                             <div id="class-icons-host" style="display: flex; gap: 6px;">
                                 <!-- Class icons will be dynamically populated here by JavaScript -->
                             </div>
                             <div class="toolbar-separator"></div>
                             <button id="delete-selected" class="btn btn-danger class-icon-button" title="Delete Selected">
                                 <svg viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 7l16 0" /><path d="M10 11l0 6" /><path d="M14 11l0 6" /><path d="M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2 -2l1 -12" /><path d="M9 7v-3a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v3" /></svg>
                             </button>
                             <button id="clear-all" class="btn btn-danger class-icon-button" title="Clear All">
                                 <svg viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0" /><path d="M5.7 5.7l12.6 12.6" /></svg>
                             </button>
                         </div>
                     </div>
                     <canvas id="canvas" width="800" height="600"></canvas>
                </div>
            </div>
            
            <div class="sidebar">
                <!-- Removed Image Source dropdown -->
                
                <!-- Local file upload -->
                <div id="local-fields">
                    <div class="form-group">
                        <label for="local-file">Choose Image File:</label>
                        <input type="file" id="local-file" accept="image/*">
                    </div>
                </div>
                
                <!-- Removed Load Image button -->
                
                <!-- Object Class selection - Removed from here -->
                
                <div class="form-group">
                    <div class="sidebar-warning"><strong>Note:</strong> For best results, ensure the 'Perimeter' annotation is drawn last.</div>
                    <label>Annotations:</label>
                    <div class="annotations-list" id="annotations-list"></div>
                </div>
                
                <button id="save-annotations" class="btn">Save Annotations</button>
                
                <div id="status-message" class="status-message"></div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Theme toggle functionality
            const themeToggle = document.getElementById('theme-toggle');
            
            // Check for saved theme preference or prefer-color-scheme
            const prefersDarkScheme = window.matchMedia('(prefers-color-scheme: dark)');
            const currentTheme = localStorage.getItem('theme');
            
            if (currentTheme === 'dark') {
                document.body.classList.add('dark-theme');
                themeToggle.checked = true;
            } else if (currentTheme === 'light') {
                document.body.classList.remove('dark-theme');
                themeToggle.checked = false;
            } else if (prefersDarkScheme.matches) {
                document.body.classList.add('dark-theme');
                themeToggle.checked = true;
            }
            
            themeToggle.addEventListener('change', function() {
                if (this.checked) {
                    document.body.classList.add('dark-theme');
                    localStorage.setItem('theme', 'dark');
                } else {
                    document.body.classList.remove('dark-theme');
                    localStorage.setItem('theme', 'light');
                }
            });
            
            // Initialize Fabric.js canvas
            const canvas = new fabric.Canvas('canvas', {
                selection: true
            });
            
            // Set control style for all objects (especially for rotation control)
            fabric.Object.prototype.set({
                transparentCorners: false,
                cornerColor: '#ffffff',
                cornerStrokeColor: '#9C27B0', // Use primary button color
                cornerStyle: 'circle',
                cornerSize: 10,
                padding: 5,
                rotatingPointOffset: 30, // Increased distance for rotation control
                borderColor: '#9C27B0'   // Highlight border color
            });
            
            let drawingMode = false;
            let currentShape = null;
            let startX, startY;
            let activeShape = null;
            let annotations = [];
            
            // DOM elements
            const drawRectBtn = document.getElementById('draw-rect');
            const deleteSelectedBtn = document.getElementById('delete-selected');
            const clearAllBtn = document.getElementById('clear-all');
            const loadImageBtn = document.getElementById('load-image');
            const saveAnnotationsBtn = document.getElementById('save-annotations');
            const apiKeyInput = document.getElementById('api-key');
            const datasetIdInput = document.getElementById('dataset-id');
            const imageIdInput = document.getElementById('image-id');
            const classIconsHost = document.getElementById('class-icons-host'); // New host for dynamic class icons
            const selectModeBtn = document.getElementById('select-mode-btn'); // New select button
            const annotationsList = document.getElementById('annotations-list');
            const statusMessage = document.getElementById('status-message');
            const localFileInput = document.getElementById('local-file');
            
            // Source selection fields
            const sourceFields = {
                local: document.getElementById('local-fields'),
            };

            // Class configuration: shape and color
            const classConfig = {
                perimeter: { 
                    shape: 'polygon', stroke: '#FF0000', fill: 'transparent', 
                    displayName: 'Perimeter', 
                    iconSvg: '<svg viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 8v-2a2 2 0 0 1 2 -2h2" /><path d="M4 16v2a2 2 0 0 0 2 2h2" /><path d="M16 4h2a2 2 0 0 1 2 2v2" /><path d="M16 20h2a2 2 0 0 0 2 -2v-2" /><path d="M12 12m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0" /></svg>'
                },
                vent: { 
                    shape: 'rectangle', stroke: '#0000FF', fill: 'rgba(0, 0, 255, 0.2)', 
                    displayName: 'Vent', 
                    iconSvg: '<svg viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 3m0 2a2 2 0 0 1 2 -2h10a2 2 0 0 1 2 2v14a2 2 0 0 1 -2 2h-10a2 2 0 0 1 -2 -2z" /><path d="M9 12l6 0" /><path d="M12 9l0 6" /></svg>'
                },
                valley: { 
                    shape: 'polygon', stroke: '#00FF00', fill: 'rgba(0, 255, 0, 0.2)', 
                    displayName: 'Valley', 
                    iconSvg: '<svg viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M3 12l18 0" /></svg>'
                },
                vertical_wall: { 
                    shape: 'polygon', stroke: '#FFA500', fill: 'rgba(255, 165, 0, 0.2)', 
                    displayName: 'Wall', 
                    iconSvg: '<svg viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M8 4h8" /><path d="M8 20h8" /><path d="M12 4v16" /></svg>'
                },
                ridges: { 
                    shape: 'polygon', stroke: '#A52A2A', fill: 'rgba(165, 42, 42, 0.2)', 
                    displayName: 'Ridge', 
                    iconSvg: '<svg viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M3 12l4 -4l4 4l4 -4l4 4l4 -4" /></svg>'
                }
            };
            
            let currentDrawingConfig = null; 
            let currentSelectedClass = null; 
            let isDrawingPolygon = false;
            let currentPolygonPoints = [];
            let tempPolygonPreview = null; 
            let currentPolygonPointHandles = []; // To store Fabric objects for point handles
            let tempRubberBandLine = null; // For the live preview line to the cursor

            if (sourceFields.local) { // Ensure local file input is always visible
                sourceFields.local.style.display = 'block';
            }
            
            deleteSelectedBtn.addEventListener('click', deleteSelected);
            clearAllBtn.addEventListener('click', clearAll);
            saveAnnotationsBtn.addEventListener('click', saveAnnotations);
            selectModeBtn.addEventListener('click', function() { // Listener for the new select button
                setModeForSelectedClass(null);
            });
            
            localFileInput.addEventListener('change', handleLocalFileSelect);
            
            // Function to render class icons
            function renderClassIcons() {
                classIconsHost.innerHTML = ''; // Clear existing icons from the host
                Object.keys(classConfig).forEach(key => {
                    const classInfo = classConfig[key];
                    const iconButton = document.createElement('div');
                    iconButton.className = 'class-icon-button';
                    iconButton.innerHTML = classInfo.iconSvg; // Use SVG for icon
                    iconButton.style.color = classInfo.stroke; // SVG will use this for stroke/fill via currentColor
                    iconButton.title = classInfo.displayName || key;
                    iconButton.dataset.classKey = key;

                    iconButton.addEventListener('click', function() {
                        const clickedClassKey = this.dataset.classKey;
                        if (this.classList.contains('active-icon')) {
                            // If already active, deselect and go to select mode
                            setModeForSelectedClass(null);
                        } else {
                            currentSelectedClass = clickedClassKey; // Set before calling
                            setModeForSelectedClass(clickedClassKey);
                        }
                    });
                    classIconsHost.appendChild(iconButton); // Append to the correct host
                });
            }
            
            // Call renderClassIcons on DOMContentLoaded
            renderClassIcons();

            // Function to set mode based on class selection (now takes className directly)
            function setModeForSelectedClass(className) {
                currentSelectedClass = className; // Update global tracker

                // Update active state of icons
                selectModeBtn.classList.remove('active-icon');
                Array.from(classIconsHost.children).forEach(btn => {
                    btn.classList.remove('active-icon');
                });

                if (className && classConfig[className]) {
                    const classButton = classIconsHost.querySelector(`[data-class-key="${className}"]`);
                    if (classButton) {
                        classButton.classList.add('active-icon');
                    }

                    currentDrawingConfig = classConfig[className];
                    currentShape = currentDrawingConfig.shape; 
                    drawingMode = true; 

                    // Clear previous polygon drawing artifacts if any
                    if (tempPolygonPreview) canvas.remove(tempPolygonPreview);
                    tempPolygonPreview = null;
                    if (tempRubberBandLine) canvas.remove(tempRubberBandLine);
                    tempRubberBandLine = null;
                    currentPolygonPointHandles.forEach(handle => canvas.remove(handle));
                    currentPolygonPointHandles = [];
                    currentPolygonPoints = [];

                    if (currentShape === 'polygon') {
                        isDrawingPolygon = true; // Set this flag only when starting a polygon for this class
                        canvas.selection = false;
                        canvas.defaultCursor = 'crosshair';
                        setStatus(`Draw ${classConfig[className]?.displayName}: Click to add points. Click the first point (white square) to close & finish.`, 'success');
                    } else {
                        isDrawingPolygon = false; 
                        canvas.selection = false; // Disable selection for drawing other shapes
                        canvas.defaultCursor = 'crosshair';
                        
                        // Add special instructions for rectangles
                        if (currentShape === 'rectangle') {
                            setStatus(`Drawing mode: ${classConfig[className]?.displayName} (${currentShape}). After drawing, you can rotate the rectangle using the rotation control.`, 'success');
                        } else {
                            setStatus(`Drawing mode: ${classConfig[className]?.displayName} (${currentShape})`, 'success');
                        }
                    }
                } else { // Selection mode (className is null or invalid)
                    currentSelectedClass = null; // Ensure this is explicit for selection mode
                    drawingMode = false;
                    isDrawingPolygon = false;
                    currentDrawingConfig = null;
                    currentShape = null;

                    selectModeBtn.classList.add('active-icon'); // Activate select button

                    if (tempPolygonPreview) canvas.remove(tempPolygonPreview);
                    tempPolygonPreview = null;
                    if (tempRubberBandLine) canvas.remove(tempRubberBandLine);
                    tempRubberBandLine = null;
                    currentPolygonPointHandles.forEach(handle => canvas.remove(handle));
                    currentPolygonPointHandles = [];
                    currentPolygonPoints = [];
                    canvas.selection = true; // Enable selection
                    canvas.defaultCursor = 'default';
                    if (annotations.length === 0 && !window.currentImage) {
                         setStatus('Selection mode. Load an image, then click a class icon to draw.', '');
                    } else if (annotations.length === 0 && window.currentImage) {
                         setStatus('Selection mode. Click a class icon to draw annotations.', '');
                    } else {
                         setStatus('Selection mode. Select an object or click a class icon to draw more.', '');
                    }
                }
            }

            // Initialize mode on page load based on the default (empty) class selection
            setModeForSelectedClass(null); // Initial call with no class selected (Select mode active)

            canvas.on('mouse:down', onMouseDown);
            canvas.on('mouse:move', onMouseMove);
            canvas.on('mouse:up', onMouseUp);
            canvas.on('mouse:dblclick', onMouseDblClick); // Added for finishing polygons
            canvas.on('object:modified', onObjectModified); // Add listener for object modifications
            canvas.on('selection:created', onObjectSelected); // Add listener for object selection
            canvas.on('selection:updated', onObjectSelected); // When selection changes between objects
            canvas.on('selection:cleared', onSelectionCleared); // When selection is cleared
            
            function capitalizeFirstLetter(string) {
                return string.charAt(0).toUpperCase() + string.slice(1);
            }
            
            function onMouseDown(options) {
                if (!drawingMode || !currentDrawingConfig) return; 

                const pointer = canvas.getPointer(options.e);
                const currentClassName = currentSelectedClass; 

                if (currentShape === 'polygon') {
                    // If a rubber band line exists, remove it as this click finalizes its end point.
                    if (tempRubberBandLine) {
                        canvas.remove(tempRubberBandLine);
                        tempRubberBandLine = null;
                    }

                    currentPolygonPoints.push({ x: pointer.x, y: pointer.y });

                    const pointHandleSize = 8;
                    const handle = new fabric.Rect({
                        left: pointer.x - pointHandleSize / 2,
                        top: pointer.y - pointHandleSize / 2,
                        width: pointHandleSize,
                        height: pointHandleSize,
                        fill: 'white',
                        stroke: 'black',
                        strokeWidth: 1,
                        selectable: false, 
                        evented: true, // Make sure it can receive events
                        objectCaching: false,
                        isPolygonHandle: true,
                        pointIndex: currentPolygonPoints.length - 1
                    });

                    handle.on('mousedown', function() { // Use mousedown as it's more immediate than click for this
                        if (this.pointIndex === 0 && currentPolygonPoints.length >= 3) {
                            completePolygonDrawing();
                        } 
                        // Else: clicking other handles does nothing for now, could enable point moving later
                    });

                    canvas.add(handle);
                    currentPolygonPointHandles.push(handle);

                    // Update the main polyline preview (committed lines)
                    if (currentPolygonPoints.length > 1) {
                        if (tempPolygonPreview) {
                            canvas.remove(tempPolygonPreview); // Remove old preview
                        }
                        tempPolygonPreview = new fabric.Polyline(currentPolygonPoints, {
                            stroke: currentDrawingConfig.stroke,
                            fill: 'transparent', 
                            strokeWidth: 2,
                            selectable: false, evented: false,
                            objectCaching: false
                        });
                        canvas.add(tempPolygonPreview);
                    } else {
                        // For the very first point, there's no polyline preview yet,
                        // only the handle and the upcoming rubber-band line from mouseMove.
                    }

                    setStatus(`Added point ${currentPolygonPoints.length} for ${classConfig[currentClassName]?.displayName}. Click first point or double-click to finish.`);
                    canvas.renderAll();
                    return; 
                }

                // Logic for non-polygon shapes (rect, circle, line)
                startX = pointer.x;
                startY = pointer.y;
                const config = currentDrawingConfig;
                
                switch (currentShape) { 
                    case 'rectangle':
                        activeShape = new fabric.Rect({
                            left: startX, top: startY, width: 0, height: 0,
                            stroke: config.stroke, strokeWidth: 2, fill: config.fill, selectable: true,
                            hasControls: true, transparentCorners: false, cornerColor: '#ffffff',
                            cornerStrokeColor: config.stroke, cornerSize: 8, rotatingPointOffset: 25,
                            cornerStyle: 'circle', rotatingPointOffset: 25
                        });
                        break;
                    case 'circle':
                        activeShape = new fabric.Circle({
                            left: startX, top: startY, radius: 0,
                            stroke: config.stroke, strokeWidth: 2, fill: config.fill, selectable: true,
                            hasControls: true
                        });
                        break;
                    case 'line':
                        activeShape = new fabric.Line([startX, startY, startX, startY], {
                            stroke: config.stroke, strokeWidth: 3, selectable: true,
                            hasControls: true
                        });
                        break;
                }
                if (activeShape) canvas.add(activeShape).renderAll();
            }
            
            function onMouseMove(options) {
                if (!drawingMode || !currentDrawingConfig) return;
                const pointer = canvas.getPointer(options.e);

                if (isDrawingPolygon && currentPolygonPoints.length > 0) {
                    if (tempRubberBandLine) {
                        canvas.remove(tempRubberBandLine);
                    }
                    const lastPoint = currentPolygonPoints[currentPolygonPoints.length - 1];
                    tempRubberBandLine = new fabric.Line([lastPoint.x, lastPoint.y, pointer.x, pointer.y], {
                        stroke: currentDrawingConfig.stroke,
                        strokeWidth: 2,
                        strokeDashArray: [5, 5], // Dashed line for preview
                        selectable: false,
                        evented: false,
                        objectCaching: false
                    });
                    canvas.add(tempRubberBandLine);
                    canvas.renderAll();
                    return; 
                }

                if (!activeShape) return; // Only proceed for non-polygon shapes if activeShape exists
                
                switch (currentShape) {
                    case 'rectangle':
                        activeShape.set({
                            left: startX > pointer.x ? pointer.x : startX,
                            top: startY > pointer.y ? pointer.y : startY,
                            width: Math.abs(pointer.x - startX),
                            height: Math.abs(pointer.y - startY)
                        });
                        break;
                    case 'circle':
                        const radius = Math.sqrt(Math.pow(pointer.x - startX, 2) + Math.pow(pointer.y - startY, 2)) / 2;
                        activeShape.set({
                            left: (startX + pointer.x) / 2 - radius,
                            top: (startY + pointer.y) / 2 - radius,
                            radius: radius
                        });
                        break;
                    case 'line':
                        activeShape.set({ x2: pointer.x, y2: pointer.y });
                        break;
                }
                canvas.renderAll();
            }
            
            function onMouseUp() {
                // For polygons, onMouseUp doesn't finalize the shape. That's handled by onMouseDblClick.
                if (isDrawingPolygon || !drawingMode || !activeShape || !currentDrawingConfig) return;
                
                // This part is for non-polygon shapes (rectangle, circle)
                let isValidShape = false;
                let shapeData = {};
                const selectedClassValue = currentSelectedClass; // Use currentSelectedClass
                // If classSelect.value is empty (e.g. "--Select Class--" is chosen), then currentDrawingConfig would be null.
                // The initial check `!currentDrawingConfig` should prevent issues.
                if (!selectedClassValue || !classConfig[selectedClassValue]) {
                    //This case should ideally be caught by currentDrawingConfig being null
                    canvas.remove(activeShape);
                    activeShape = null;
                    setStatus('Invalid class selected or no class selected.', 'error');
                    return;
                }
                const config = currentDrawingConfig; // Relies on classSelect having a valid selected class

                switch (currentShape) { // currentShape is derived from currentDrawingConfig.shape
                    case 'rectangle':
                        isValidShape = activeShape.width >= 5 && activeShape.height >= 5;
                        if (isValidShape) {
                            shapeData = {
                                x: activeShape.left / canvas.width, // Top-left x before rotation
                                y: activeShape.top / canvas.height, // Top-left y before rotation
                                width: activeShape.width / canvas.width,
                                height: activeShape.height / canvas.height,
                                angle: activeShape.angle || 0 // Store the angle
                            };
                        }
                        break;
                    case 'circle':
                        isValidShape = activeShape.radius >= 3;
                        if (isValidShape) {
                            const centerX = activeShape.left + activeShape.radius;
                            const centerY = activeShape.top + activeShape.radius;
                            shapeData = { x: centerX / canvas.width, y: centerY / canvas.height, radius: activeShape.radius / Math.max(canvas.width, canvas.height) };
                        }
                        break;
                    case 'line':
                        const lineLength = Math.sqrt(Math.pow(activeShape.x2 - activeShape.x1, 2) + Math.pow(activeShape.y2 - activeShape.y1, 2));
                        isValidShape = lineLength >= 5;
                        if (isValidShape) shapeData = { x1: activeShape.x1 / canvas.width, y1: activeShape.y1 / canvas.height, x2: activeShape.x2 / canvas.width, y2: activeShape.y2 / canvas.height };
                        break;
                }
                
                if (!isValidShape) {
                    canvas.remove(activeShape);
                    setStatus('Shape too small, not added.', 'error');
                } else {
                    const annotationId = Date.now().toString();
                    const annotation = {
                        id: annotationId, class: selectedClassValue, type: currentShape, 
                        color: config.stroke, // Store stroke color for identification
                        ...shapeData, shape: activeShape
                    };
                    annotations.push(annotation);
                    
                    activeShape.id = annotationId;
                    activeShape.class = selectedClassValue;
                    activeShape.shapeType = currentShape;
                    
                    let labelLeft, labelTop;
                    const labelText = selectedClassValue;
                    const textPadding = 3;
                    const textFontSize = 12;

                    switch (currentShape) {
                        case 'rectangle':
                            labelLeft = activeShape.left;
                            labelTop = activeShape.top - textFontSize - (textPadding*2) < 0 ? activeShape.top + activeShape.height + textPadding : activeShape.top - textFontSize - (textPadding*2) -1 ;
                            break;
                        case 'circle':
                             const textWidth = labelText.length * (textFontSize / 2); // Approx width
                            labelLeft = activeShape.left + activeShape.radius - textWidth / 2;
                            labelTop = activeShape.top - textFontSize - (textPadding*2) < 0 ? activeShape.top + (activeShape.radius * 2) + textPadding : activeShape.top - textFontSize - (textPadding*2) -1;
                            break;
                        case 'line':
                            const midX = (activeShape.x1 + activeShape.x2) / 2;
                            const midY = (activeShape.y1 + activeShape.y2) / 2;
                            labelLeft = midX - (labelText.length * (textFontSize / 2) / 2);
                            labelTop = midY - textFontSize - textPadding;
                            break;
                    }
                    
                    const label = new fabric.Text(labelText, {
                        left: labelLeft, top: labelTop, fontSize: textFontSize,
                        fill: '#fff', backgroundColor: config.stroke, padding: textPadding,
                        selectable: false, evented: false
                    });
                    canvas.add(label);
                    activeShape.label = label;
                    
                    updateAnnotationsList();
                    setStatus(`Annotation for ${selectedClassValue} added.`, 'success');
                }
                activeShape = null;
                // Keep drawing mode active for the selected class unless changed
            }
            
            function onMouseDblClick(options) {
                if (isDrawingPolygon && currentPolygonPoints.length >= 3) {
                    completePolygonDrawing();
                } 
                // No specific action if not drawing polygon or not enough points for dbl click to finalize
            }
            
            function completePolygonDrawing() {
                if (!isDrawingPolygon || currentPolygonPoints.length < 3) {
                    setStatus('Polygon needs at least 3 points.', 'error');
                    return;
                }

                if (tempRubberBandLine) { // Ensure rubber band line is removed on completion
                    canvas.remove(tempRubberBandLine);
                    tempRubberBandLine = null;
                }

                canvas.remove(tempPolygonPreview); 
                tempPolygonPreview = null;

                currentPolygonPointHandles.forEach(handle => canvas.remove(handle));
                currentPolygonPointHandles = [];

                const currentClassName = currentSelectedClass;
                const config = classConfig[currentClassName];

                const finalPolygon = new fabric.Polygon(currentPolygonPoints, {
                    stroke: config.stroke,
                    strokeWidth: 2,
                    fill: config.fill, 
                    selectable: true,
                    hasControls: true,
                    objectCaching: false 
                });

                const annotationId = Date.now().toString();
                const normalizedPoints = currentPolygonPoints.map(p => ({
                    x: p.x / canvas.width,
                    y: p.y / canvas.height
                }));

                const annotation = {
                    id: annotationId,
                    class: currentClassName,
                    type: 'polygon',
                    points: normalizedPoints, 
                    color: config.stroke, 
                    shape: finalPolygon
                };
                annotations.push(annotation);

                finalPolygon.id = annotationId;
                finalPolygon.class = currentClassName;
                finalPolygon.shapeType = 'polygon';

                let labelLeft = currentPolygonPoints[0].x;
                let labelTop = currentPolygonPoints[0].y - 15;
                if (labelTop < 0) labelTop = currentPolygonPoints[0].y + 5;

                const label = new fabric.Text(config.displayName, {
                    left: labelLeft, top: labelTop, fontSize: 12,
                    fill: '#fff', backgroundColor: config.stroke, padding: 3,
                    selectable: false, evented: false
                });
                canvas.add(finalPolygon).add(label);
                finalPolygon.label = label;

                updateAnnotationsList();
                setStatus(`Polygon for ${config.displayName} added with ${currentPolygonPoints.length} points.`, 'success');
                
                isDrawingPolygon = false;
                currentPolygonPoints = [];
                // After completing a polygon, reset to selection mode for that class or global selection if needed
                // For now, let current class selection persist, user can click another icon or deselect current
                // setModeForSelectedClass(currentSelectedClass); // Re-affirm current class mode, or pass null for general selection mode
                canvas.renderAll();
            }
            
            function deleteSelected() {
                const activeObject = canvas.getActiveObject();
                
                if (!activeObject) {
                    setStatus('No object selected', 'error');
                    return;
                }
                
                if (activeObject.id) {
                    // Remove from annotations array
                    annotations = annotations.filter(anno => anno.id !== activeObject.id);
                    
                    // Remove label if exists
                    if (activeObject.label) {
                        canvas.remove(activeObject.label);
                    }
                    
                    // Remove the shape
                    canvas.remove(activeObject);
                    canvas.renderAll();
                    
                    // Update annotations list
                    updateAnnotationsList();
                    
                    setStatus('Annotation deleted', 'success');
                }
            }
            
            function clearAll() {
                canvas.clear();
                annotations = [];
                updateAnnotationsList();
                
                // If we have a background image, reload it
                if (window.currentImage) {
                    fabric.Image.fromURL(window.currentImage, function(img) {
                        canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), {
                            scaleX: canvas.width / img.width,
                            scaleY: canvas.height / img.height
                        });
                    });
                }
                
                setStatus('All annotations cleared', 'success');
            }
            
            function handleLocalFileSelect(event) {
                const file = event.target.files[0];
                
                if (!file) {
                    return;
                }
                
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    loadImageFromUrl(e.target.result);
                };
                
                reader.onerror = function() {
                    setStatus('Error reading file', 'error');
                };
                
                setStatus('Loading local image...', '');
                reader.readAsDataURL(file);
            }
            
            function loadImageFromUrl(url) {
                window.currentImage = url;
                
                fabric.Image.fromURL(url, function(img) {
                    // Clear the canvas first
                    clearAll();
                    
                    // Calculate scaling to fit the canvas while maintaining aspect ratio
                    const canvasRatio = canvas.width / canvas.height;
                    const imgRatio = img.width / img.height;
                    
                    let scaleX, scaleY;
                    
                    if (imgRatio > canvasRatio) {
                        // Image is wider than canvas (relative to height)
                        scaleX = canvas.width / img.width;
                        scaleY = scaleX;
                    } else {
                        // Image is taller than canvas (relative to width)
                        scaleY = canvas.height / img.height;
                        scaleX = scaleY;
                    }
                    
                    // Set the image as background
                    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), {
                        scaleX: scaleX,
                        scaleY: scaleY,
                        originX: 'left',
                        originY: 'top'
                    });
                    
                    setStatus('Image loaded successfully', 'success');
                }, { crossOrigin: 'anonymous' });
            }
            
            function saveAnnotations() {
                const apiKey = apiKeyInput.value; // This is no longer used but kept in original func structure
                const datasetId = datasetIdInput.value; // ditto
                const imageId = imageIdInput.value; // ditto
                
                // API key/Dataset ID check removed as they are not used for local saving
                // if (!apiKey || !datasetId || !imageId) {
                //     setStatus('Please provide API key, dataset ID and image ID', 'error');
                //     return;
                // }
                
                if (annotations.length === 0) {
                    setStatus('No annotations to save', 'error');
                    return;
                }
                
                // Format the annotations for YOLOv11-seg
                const yoloFormattedAnnotations = annotations.map(anno => {
                    const classIndex = Object.keys(classConfig).indexOf(anno.class); // Get class index
                    if (classIndex === -1) {
                        console.warn(`Class ${anno.class} not found in classConfig, skipping annotation ${anno.id}`);
                        return null; // Skip if class is not recognized
                    }

                    let yoloString = `${classIndex}`;

                    switch (anno.type) {
                        case 'rectangle':
                            // For YOLO segmentation, all rectangles (rotated or not) are exported as 4-point polygons.
                            const rectObj = anno.shape; // The fabric object
                            const coords = rectObj.oCoords; // Get corner coordinates after transformations

                            if (!coords) {
                                console.warn(`Could not get oCoords for rectangle annotation ${anno.id}, skipping.`);
                                return null;
                            }

                            // Order: tl, tr, br, bl (top-left, top-right, bottom-right, bottom-left)
                            // Ensure these points are in a consistent order for polygon representation.
                            yoloString += ` ${(coords.tl.x / canvas.width).toFixed(6)} ${(coords.tl.y / canvas.height).toFixed(6)}`;
                            yoloString += ` ${(coords.tr.x / canvas.width).toFixed(6)} ${(coords.tr.y / canvas.height).toFixed(6)}`;
                            yoloString += ` ${(coords.br.x / canvas.width).toFixed(6)} ${(coords.br.y / canvas.height).toFixed(6)}`;
                            yoloString += ` ${(coords.bl.x / canvas.width).toFixed(6)} ${(coords.bl.y / canvas.height).toFixed(6)}`;
                            break;
                        case 'circle':
                            // Approximate circle with a polygon (e.g., 16-sided)
                            const numSegments = 16;
                            let circlePointsStr = '';
                            for (let i = 0; i < numSegments; i++) {
                                const angle = (i / numSegments) * 2 * Math.PI;
                                const pointX = anno.x + anno.radius * Math.cos(angle); // anno.x is centerX, anno.radius is normalized
                                const pointY = anno.y + anno.radius * Math.sin(angle); // anno.y is centerY
                                circlePointsStr += ` ${pointX.toFixed(6)} ${pointY.toFixed(6)}`;
                            }
                            yoloString += circlePointsStr;
                            break;
                        case 'polygon':
                            let polyPointsStr = '';
                            anno.points.forEach(p => {
                                polyPointsStr += ` ${p.x.toFixed(6)} ${p.y.toFixed(6)}`;
                            });
                            yoloString += polyPointsStr;
                            break;
                        // 'line' is not directly a YOLO segmentation shape unless treated as a thin polygon.
                        // Current lines will be exported as polygons if their class maps to polygon.
                        // If a class strictly maps to 'line' and needs different export, add case here.
                        default:
                            console.warn(`Unsupported annotation type for YOLO export: ${anno.type}, skipping.`);
                            return null;
                    }
                    return yoloString;
                }).filter(Boolean); // Remove nulls from skipped annotations
                
                const payload = {
                    // Define how you want to save: e.g., to a .txt file per image for YOLO
                    // For now, displaying in status. In a real app, trigger a download.
                    yoloAnnotations: yoloFormattedAnnotations.join('\n') // Each annotation on a new line
                };
                
                setStatus('YOLOv11-seg formatted annotations (see console for payload): ' + JSON.stringify(payload, null, 2), 'success');
                console.log("YOLO Formatted Annotations Payload:", payload);
                
                // Example for triggering download (you might need a library or more robust solution)
                const filename = "annotations.txt";
                const element = document.createElement('a');
                element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(payload.yoloAnnotations));
                element.setAttribute('download', filename);
                element.style.display = 'none';
                document.body.appendChild(element);
                element.click();
                document.body.removeChild(element);
            }
            
            function updateAnnotationsList() {
                annotationsList.innerHTML = '';
                const defaultBorderColor = getComputedStyle(document.documentElement).getPropertyValue('--anno-item-border').trim();
                
                if (annotations.length === 0) {
                    annotationsList.innerHTML = '<p>No annotations yet. Select a class to draw.</p>';
                    return;
                }
                
                annotations.forEach(anno => {
                    const item = document.createElement('div');
                    item.className = 'annotation-item';
                    const classColor = classConfig[anno.class]?.stroke || anno.color || defaultBorderColor;
                    item.style.borderLeft = `4px solid ${classColor}`;

                    let details = '';
                    switch (anno.type) {
                        case 'rectangle':
                            details = `<strong>Type:</strong> Rectangle<br>
                                       <strong>Original Pos:</strong> (${Math.round(anno.x * 100)}%, ${Math.round(anno.y * 100)}%)<br>
                                       <strong>Size:</strong> ${Math.round(anno.width * 100)}% × ${Math.round(anno.height * 100)}%`;
                            if (anno.angle && Math.abs(anno.angle) > 0.1) { // Show angle if not negligible
                                details += `<br><strong>Angle:</strong> ${Math.round(anno.angle)}°`;
                            }
                            break;
                        case 'polygon': // Updated to display polygon points count
                            const pointsCount = anno.points ? anno.points.length : 0;
                            details = `<strong>Type:</strong> Polygon<br><strong>Points:</strong> ${pointsCount}`;
                            if (pointsCount > 0 && anno.points[0]){
                                details += `<br><strong>Start:</strong> (${Math.round(anno.points[0].x * 100)}%, ${Math.round(anno.points[0].y * 100)}%)`;
                            }
                            break;
                        case 'circle':
                            details = `<strong>Type:</strong> Circle<br><strong>Center:</strong> (${Math.round(anno.x * 100)}%, ${Math.round(anno.y * 100)}%)<br><strong>Radius:</strong> ${Math.round(anno.radius * 100)}%`;
                            break;
                        case 'line':
                            details = `<strong>Type:</strong> Line<br><strong>Start:</strong> (${Math.round(anno.x1 * 100)}%, ${Math.round(anno.y1 * 100)}%)<br><strong>End:</strong> (${Math.round(anno.x2 * 100)}%, ${Math.round(anno.y2 * 100)}%)`;
                            break;
                        default:
                            details = `<strong>Type:</strong> ${anno.type || 'Unknown'}`;
                    }
                    item.innerHTML = `<strong>Class:</strong> ${anno.class}<br>${details}`;
                    annotationsList.appendChild(item);
                });
            }
            
            function setStatus(message, type) {
                statusMessage.textContent = message;
                statusMessage.className = 'status-message';
                
                if (type) {
                    statusMessage.classList.add(type);
                }
            }
            
            // Function to handle object selection
            function onObjectSelected(options) {
                const selectedObject = options.selected[0]; // Get first selected object
                if (selectedObject && selectedObject.shapeType === 'rectangle') {
                    setStatus(`Rectangle selected. Use the circular handle to rotate.`, 'success');
                }
            }
            
            // Function to handle selection cleared
            function onSelectionCleared() {
                // If there's a drawing mode active, revert to that message
                if (drawingMode && currentDrawingConfig) {
                    const currentClassName = currentSelectedClass;
                    if (currentShape === 'rectangle') { // rectangle drawing has specific hint
                        setStatus(`Drawing mode: ${classConfig[currentClassName]?.displayName} (rectangle). After drawing, you can rotate the rectangle.`, 'success');
                    } else if (currentShape === 'polygon') {
                        setStatus(`Draw ${classConfig[currentClassName]?.displayName}: Click to add points, double-click to finish.`, 'success');
                    } else {
                        setStatus(`Drawing mode: ${classConfig[currentClassName]?.displayName} (${currentShape})`, 'success');
                    }
                } else if (annotations.length === 0 && !window.currentImage) {
                    setStatus('Selection mode. Load an image, then click a class icon to draw.', '');
                } else if (annotations.length === 0 && window.currentImage) {
                    setStatus('Selection mode. Click a class icon to draw annotations.', '');
                } else {
                    setStatus('Selection mode. Select an object or click a class icon to draw more.', '');
                }
            }
            
            // Function to update annotation data when objects are modified
            function onObjectModified(options) {
                const modifiedObject = options.target;
                if (!modifiedObject || !modifiedObject.id) return;
                
                // Find the annotation that corresponds to this object
                const annotation = annotations.find(anno => anno.id === modifiedObject.id);
                if (!annotation) return;
                
                // Update the annotation data based on the type of object
                switch (annotation.type) {
                    case 'rectangle':
                        annotation.x = modifiedObject.left / canvas.width;
                        annotation.y = modifiedObject.top / canvas.height;
                        annotation.width = modifiedObject.width / canvas.width;
                        annotation.height = modifiedObject.height / canvas.height;
                        annotation.angle = modifiedObject.angle || 0;
                        
                        // Update label position
                        if (modifiedObject.label) {
                            let labelLeft = modifiedObject.left;
                            let labelTop = modifiedObject.top - 15;
                            if (labelTop < 0) labelTop = modifiedObject.top + modifiedObject.height + 5;
                            modifiedObject.label.set({
                                left: labelLeft,
                                top: labelTop
                            });
                        }
                        break;
                    case 'circle':
                        // Update circle annotation data
                        const centerX = modifiedObject.left + modifiedObject.radius;
                        const centerY = modifiedObject.top + modifiedObject.radius;
                        annotation.x = centerX / canvas.width;
                        annotation.y = centerY / canvas.height;
                        annotation.radius = modifiedObject.radius / Math.max(canvas.width, canvas.height);
                        
                        // Update label position
                        if (modifiedObject.label) {
                            const textWidth = modifiedObject.label.text.length * (12 / 2); // Approx width
                            modifiedObject.label.set({
                                left: centerX - textWidth / 2,
                                top: centerY - modifiedObject.radius - 15
                            });
                        }
                        break;
                    case 'polygon':
                        // Update polygon points
                        if (modifiedObject.points) {
                            annotation.points = modifiedObject.points.map(p => ({
                                x: (modifiedObject.left + p.x) / canvas.width,
                                y: (modifiedObject.top + p.y) / canvas.height
                            }));
                            
                            // Update label position
                            if (modifiedObject.label) {
                                modifiedObject.label.set({
                                    left: modifiedObject.left,
                                    top: modifiedObject.top - 15
                                });
                            }
                        }
                        break;
                }
                
                // Update the annotations list
                updateAnnotationsList();
                canvas.renderAll();
            }
            
            updateAnnotationsList();
        });
    </script>
</body>
</html>